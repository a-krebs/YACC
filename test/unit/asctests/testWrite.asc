# Expected return:
# ZT&ZT&ZT&ZT&ZT&!!! 123321123

test_start		CONSTI 0
			CONSTI 0
			CONSTI 90
			CONSTI 84
			CONSTI 38
			CONSTI 90
			CONSTI 84
			CONSTI 38
			CONSTI 90
			CONSTI 84
			CONSTI 38
			CONSTI 90
			CONSTI 84
			CONSTI 38
			CONSTI 90
			CONSTI 84
			CONSTI 38
			CONSTI 15
			CALL 0, __write_str
			CONSTI 33
			CONSTI 33
			CONSTI 33
			CONSTI 3
			CALL 0, __write_str
			CONSTI 123321123
			CALL 0, __write_int
			STOP
			

# ASC code for the predefined function abs(x)
# Works as follows: if x < 0, return x * (-1), else return x. 
# __abs_int, __abs_real work for ints and reals respectively

__abs_int	PUSH -3[0]		# push x onto stack
		CONSTI 0		# push 0 onto stack
		LTI			# if x < 0, push 1, else push 0
		IFZ __abs_pos		# x >= 0, just return x
		PUSH -3[0]		# x < 0, push it onto stack
		CONSTI -1		# push -1 onto stack
		MULI			# top of stack <-- x * (-1)
		POP -4[0]		# place x in ret value location in stack
		GOTO __abs_ret

__abs_real	PUSH -3[0]		# push x onto stack
		CONSTR 0.0		# push 0 onto stack
		LTR			# if x < 0 push 1, else push 0
		IFZ __abs_pos		# x >= 0, just return x
		PUSH -3[0]		# if x < 0, push it onto stack
		CONSTR -1.0		# push -1.0 onto stack
		MULR			# top of stack <-- x * (-1.0)
		POP -4[0]		# place x in ret value location in stack
		GOTO __abs_ret

__abs_pos	PUSH -3[0]		# x is positive, push it onto stack
		POP -4[0]		# place x in ret value location in stack
		GOTO __abs_ret	

__abs_ret	RET 0

###############################################################################
# arctan(x) - returns the value of the arctan of x where x is in radians.
# We're going to approximate the value of arctan by calculating "enough" terms
# of its Taylor series.
# TODO: only works for small values of x!  need more general solution :(
###############################################################################

__arctan_int		PUSH -3[0]	# push x onto stack
			ITOR		# conver to real
			POP -3[0]	# push into param slot
			GOTO __arctan_real # "call" real valued version of sin()

__arctan_real		ADJUST 1	# make room for k = summation index
					# in the taylor series for sine
			CONSTI 6	# We are going to sum the first 6
					# series
			POP 0[0]

			ADJUST 1	# make room for (-1)^k
			CONSTR 0.0	
			POP 1[0]	# set (-1)^k = 0 for now

			ADJUST 1	# make room for (2k + 1)
			CONSTR 0.0
			POP 2[0]	# set it to zero for now

			ADJUST 1	# make room for x^(2k+1) and set to 0
			CONSTR 0.0
			POP 3[0]

			# make room for value of sum so far, set to 0
			ADJUST 1	
			CONSTR 0.0
			POP 4[0]

			GOTO __arctan_loop

__arctan_loop		PUSH 0[0]	# push k onto stack
			CONSTI -1	# push -1 onto stack
			ADDI		# k <- k-1
			POP 0[0]	# save new value of k
			PUSH 0[0]	# push k onto stack
			CONSTI 0	# push 0 onto stack
			LTI
			IFNZ __arctan_done	# k < 0 => we are done
			# else, we calculate the next summand

			#first calculate (-1)^k, make call to __pow_int_int
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k as second param
			CONSTI -1	# push -1 as first param
			CALL 0, __pow_int_int
			ADJUST -2	# kick params off the stack
			POP 1[0]	# save (-1)^k back into local vars
			#next calculate (2k + 1)
			PUSH 0[0]	# push k onto stack
			CONSTI 2	# push 2 onto stack
			MULI		# top of stack <-- 2*k
			CONSTI 1	# push 1 onto stack
			ADDI		# top of stack <-- 2*k + 1
			ITOR		# make 2*k + 1 a real
			POP 2[0]	# save (2k+1) back into local vars
			# next we calculate x^(2k+1)
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k onto stack
			CONSTI 2	# push 2 onto stack
			MULI		# top of stack <-- 2*k
			CONSTI 1	# push 1 onto stack
			ADDI		# top of stack <-- 2k+1
			PUSH -3[0]	# push x onto stack
			CALL 0, __pow_real_int
			ADJUST -2	# kick local vars off the stack
			POP 3[0]	# save val back into local vars
			# we're finally ready to calculate the summand
			PUSH 1[0]	# push (-1)^k
			PUSH 2[0]	# push (2k + 1)
			DIVR		# top of stack <-- (-1)^k/(2k+1)
			PUSH 3[0]	# push x^(2k+1)
			MULR		# top of stack <-- summand
			PUSH 4[0]	# push sum so far onto stack
			ADDR		# add summand to sum so far
			POP 4[0]	# save sum so far
			GOTO __arctan_loop

__arctan_done		PUSH 4[0]	# push sum so far onto stack
			POP -4[0]	# save it as ret value
			ADJUST -5	#kick local vars off the stack
			GOTO __arctan_ret
__arctan_ret		RET 0


# ASC implementation of char() function.
# From the expression x that shall be of integer-type, this function shall
# return a result of chartype that shall be the value whose
# oridnal number is equal to the value of the expression x, if such a character
# value exists.  It shall be an error if such a character value does not
# exist.
# It shall be true that chr(ord(ch)) = ch
__chr			PUSH -3[0]	# push ch onto stack
			CONSTI 256	# push max ascii val onto stack
			GTI
			IFNZ __chr_err	# ch < 256 => not a char value
			PUSH -3[0]
			POP -4[0]	# return ch since we're using ascii
			RET 0

__chr_err		# PRINT ERROR MESSAGE
			STOP



###############################################################################
# cos(x) - returns the value of the cosine of x where x is in radians.
# We're going to approximate the value of cosine by calculating "enough" terms
# of its Taylor series.
###############################################################################

__cos_int		PUSH -3[0]	# push x onto stack
			ITOR		# convert to real
			POP -3[0]	# push into param slot
			GOTO __cos_real	# "call" real valued version of cos()

__cos_real		ADJUST 1	# make room for k = summation index
					# in the taylor series for cosine
			CONSTI 6	# We are going to sum the first 6
					# summands
			POP 0[0]

			ADJUST 1	# make room for (-1)^k
			CONSTR 0.0	
			POP 1[0]	# set (-1)^k = 0 for now

			ADJUST 1	# make room for (2k)!
			CONSTR 0.0
			POP 2[0]	# set it to zero for now

			ADJUST 1	# make room for x^(2k) and set to 0
			CONSTR 0.0
			POP 3[0]

			# make room for value of sum so far, set to 0
			ADJUST 1	
			CONSTR 0.0
			POP 4[0]

			GOTO __cos_loop

__cos_loop		PUSH 0[0]	# push k onto stack
			CONSTI -1	# push -1 onto stack
			ADDI		# k <- k-1
			POP 0[0]	# save new value of k
			PUSH 0[0]	# push k onto stack
			CONSTI 0	# push 0 onto stack
			LTI
			IFNZ __cos_done	# k < 0 => we are done
			# else, we calculate the next summand

			#first calculate (-1)^k, make call to __pow_int_int
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k as second param
			CONSTI -1	# push -1 as first param
			CALL 0, __pow_int_int
			ADJUST -2	# kick params off the stack
			POP 1[0]	# save (-1)^k back into local vars

			#next calculate (2k)!
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k onto stack
			CONSTI 2	# push 2 onto stack
			MULI		# top of stack <-- 2*k
			CALL 0, __factorial
			ADJUST -1	# kick param off stack
			POP 2[0]	# save (2k)! back into local vars

			# next we calculate x^(2k)
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k onto stack
			CONSTI 2	# push 2 onto stack
			MULI		# top of stack <-- 2*k
			PUSH -3[0]	# push x onto stack
			CALL 0, __pow_real_int
			ADJUST -2	# kick local vars off the stack
			POP 3[0]	# save val back into local vars

			# we're finally ready to calculate the summand
			PUSH 1[0]	# push (-1)^k
			PUSH 2[0]	# push (2k)!
			DIVR		# top of stack <-- (-1)^k/(2k)!
			PUSH 3[0]	# push x^(2k)
			MULR		# top of stack <-- summand
			PUSH 4[0]	# push sum so far onto stack
			ADDR		# add summand to sum so far
			POP 4[0]	# save sum so far
			GOTO __cos_loop

__cos_done		PUSH 4[0]	# push sum so far onto stack
			POP -4[0]	# save it as ret value
			ADJUST -5	#kick local vars off the stack
			GOTO __cos_ret
__cos_ret		RET 0


###############################################################################
# factorial(n) - returns n! (useful in calculating values of trig functions)
# --> returns the n! as a real such that we can express larger factorial values
###############################################################################
__factorial		ADJUST 1	# make room for local var tmp
			PUSH -3[0]	# push n onto stack
			IFZ __factorial_zero #handle special case n = 0
			PUSH -3[0]	# push n onto stack
			ITOR		# make n a real
			POP -3[0]	# save n as a real
			PUSH -3[0]	# put n onto stack
			POP 0[0]	# tmp <-- n
			GOTO __factorial_loop

__factorial_zero	CONSTR 1.0
			POP 0[0]
			GOTO __factorial_done

__factorial_loop	PUSH -3[0]	# push n onto stack
			CONSTR -1.0	# push -1 onto stack
			ADDR		# top of stack <-- n - 1
			POP -3[0]	# n <-- n - 1
			PUSH -3[0]	# push n-1 onto stack
			IFZ __factorial_done
			PUSH -3[0]	# push n-1 onto stack
			PUSH 0[0]	# push tmp onto stack
			MULR		# top of stack <-- tmp * (n - 1)
			# TODO: add test for > maxint, set run-time error 
			POP 0[0]	# tmp <-- tmp * (n - 1)
			GOTO __factorial_loop


__factorial_done	PUSH 0[0]	# push tmp onto stack
			POP -4[0]	# save tmp as ret value
			ADJUST -1	# kick local vars off stack
			GOTO __factorial_ret

__factorial_ret		RET 0

# Returns true if the given real is nan, +inf or -inf.
# Returns otherwise.
__is_bad_real	PUSH -3[0]
		RTOI
		CONSTI 2146435072	# push nan onto stack
		RTOI
		EQI
		IFNZ __is_bad_real_true
		PUSH -3[0]
		RTOI
		CONSTI 2139095040	# push +inf onto stack
		RTOI
		EQI
		IFNZ __is_bad_real_true
		PUSH -3[0]
		RTOI
		CONSTI -8388608		# push -inf onto stack
		RTOI
		EQI
		IFNZ __is_bad_real_true
		CONSTI 0
		POP -4[0]
		GOTO __is_bad_real_ret

__is_bad_real_true	CONSTI 1
			POP -4[0]
			GOTO __is_bad_real_ret

__is_bad_real_ret	RET 0


# ASC code for the predefined function odd(x)
# Definition (from standard):
# From the expression x that shall be of integer-type, this function shall be
# equivalent to the expression
# 	(abs(x) mod 2 = 1) (note abs(s) not necessary, x = -x mod 2 for all x)

__odd:		PUSH -3[0]		# push x onto the top of the stack
		CONSTI 2		# push 2 onto the top of the stack
		MOD			# top of stack <-- x mod 2
		POP -4[0]		# place result in the section of the 
					# stack reservered for return values
		RET 0			# pop the 0th display register frame

# ASC implementation of the ord() function.
# From the expression x that shall be of an ordinal-type, this function shall
# return a result of integer-type that shall be the ordinal number of the value
# of the expression x.
#
# For us this is really easy: all ordinal types are represented as ints,
# so we literally just return the value we were given.  Fantastic.
__ord		PUSH -3[0]
		POP -4[0]
		RET 0

#
# Not a pre-defined function, but a helpful one with calculations used 
# in other pre-defined functions.
# Takes as args x, n (n always int) and return x^n as a real
#
__pow_int_int		PUSH -3[0]	# push x onto stack
			ITOR		# convert it to a real
			POP -3[0]	# place it in param 1 location in stack
			GOTO __pow_real_int

__pow_real_int		PUSH -4[0]	# push n onto stack
			IFZ __pow_zeroexp	# n = 0, return 1
			PUSH -3[0]	# push x onto stack
			IFZ __pow_zerobase
			# else, nonzero base and exp and we have work to do
			ADJUST 1	# make room on stack for tmp
			PUSH -3[0]	# push x onto stack
			POP 0[0]	# store tmp <-- x, tmp will be used
					# as rolling value as we continually
					# multiply x by itself


__pow_real_int_loop	PUSH -4[0]	# n > 0, so decrement it
			CONSTI -1
			ADDI
			POP -4[0]	# n <-- n - 1
			PUSH -4[0]	#push n onto stack
			IFZ __pow_real_int_done
			PUSH 0[0]	# push tmp onto stack
			PUSH -3[0]	# push onto stack
			MULR		# top of stack <-- tmp * x
			POP 0[0]	# store result as new tmp
			GOTO __pow_real_int_loop

__pow_real_int_done	PUSH 0[0]	# put tmp on top of stack
			POP -5[0]	# save tmp as ret value
			ADJUST -1	# kick local vars off stack
			GOTO __pow_ret

__pow_zeroexp		CONSTR 1.0	# push 1.0 onto stack
			POP -5[0]	# place 1.0 in ret val location in stack
			GOTO __pow_ret

__pow_zerobase		CONSTR 0.0	# push 0.0 onto stack
			POP -5[0]	# place 0.0 in ret val location in stack
			GOTO __pow_ret

__pow_ret		RET 0


# ASC implementation of the function pred()
# From the expression x that shall be of an ordinal-type, this function shall
# return a result that shall be of the same type as that of the expression.
# The function shall yield a value whose ordinal number is one less that that
# of the expression x, if such a value exists.  It shall be an error if such a
# a value does not exist.


# __pred for integers #########################################################
__pred_int		PUSH -3[0]	# push x onto the stack
			# TODO: test if == minint
			CONSTI -1	# push -1 onto stack
			ADDI		# x <-- x-1
			POP -4[0]	# save x-1 as ret value
			RET 0	
__pred_error		# value passed == minint, no predecessor
			STOP


# __pred for booleans #########################################################

__pred_bool		PUSH -3[0]	# push x onto the stack
			CONSTI 1	# push 1 onto the stack
			EQI		# if x != 1, has no predecessor
			IFZ __pred_bool_err
			CONSTI 0	# else, save 0 as ret value
			POP -4[0]
			RET 0

__pred_bool_err		# no predecessor
			STOP

# __pred for scalar enumerations ##############################################

__pred_scalar		PUSH -3[0]	# test if x == 0
			CONSTI 0
			EQI
			IFNZ __pred_scalar_err	# x == 0, error
			PUSH -3[0]	# if not, then decrement and return
			CONSTI -1
			ADDI
			POP -4[0]
			RET 0

__pred_scalar_err	# no predecessor
			STOP

# __pred for chars ############################################################
__pred_char		PUSH -3[0]	# test if x == 0
			CONSTI 0
			EQI
			IFNZ __pred_char_err	# x == 0, error
			PUSH -3[0]	# if not, then decrement and return
			CONSTI -1
			ADDI
			POP -4[0]
			RET 0

__pred_char_err	# no predecessor
			STOP
			

# ASC implementation of read()
# Calling convention:
#	- for ints and real, just push param as usual (i.e., param is the 
#	  address where the value read in is to be placed)
#	- for chars/strs, first param is the number of chars to read (e.g.,
#	  if we want to read(s) where s : array[1..10] of char, then the first
#	  param should be 10 and read() will assume -13[0] is the address
#	  into which to return the first char read (e.g., s[1])
# NOTE: check err flag after reading from input, if it does not get the type
# it is expecting then it is a run time error and the program will halt.
__read_str		ADJUST 1	# make # of chars to read a local var
			PUSH -3[0]	
			POP 0[0]
			GOTO __read_str_loop

__read_str_loop		PUSH 0[0]	# top of stack <-- # char left to read
			IFZ __read_str_done
			# else we have more chars to read
			PUSH 0[0]
			CONSTI -1
			MULI
			CONSTI -3
			ADDI 		# top of stack <- offset to next param
			READC		# get char from stdin
			IFERR __read_str_err 
			POPI 0		# store read char at &x
			# decrement # of chars left to print
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
			GOTO __read_str_loop

__read_str_done		ADJUST -1
			RET 0

__read_str_err		CONSTI 90	# TODO: print real error message
			WRITEC
			STOP



__read_int		PUSH -3[0]	# push &x onto stack
			READI		# read int from stdin
			IFERR __read_int_err
			POPI		# pop value read from stdin to
					# address specified by param
			RET 0		
			

__read_int_err		# TODO: produce error message
			CONSTI 90
			WRITEI
			STOP

__read_real		PUSH -3[0]	# push &x onto stack
			READR		# read real from stdin
			IFERR __read_real_err
			POPI		# pop value read from stdin to addr
					# specified by param
			RET 0		

__read_real_err		STOP 		# TODO print error



# ASC implementation of readln()
# Calling convention:
#	- for ints and real, just push param as usual (i.e., param is the 
#	  address where the value read in is to be placed)
#	- for chars/strs, first param is the number of chars to read (e.g.,
#	  if we want to readln(s) where s : array[1..10] of char, then the first
#	  param should be 10 and readln() will assume -13[0] is the address
#	  into which to return the first char read (e.g., s[1])
# NOTE: check err flag after reading from input, if it does not get the type
# it is expecting then it is a run time error and the program will halt.

__readln_str		ADJUST 1	# make # of chars to read a local var
			PUSH -3[0]	
			POP 0[0]
			GOTO __readln_str_loop

__readln_str_loop	PUSH 0[0]	# top of stack <-- # char left to read
			IFZ __readln_str_done
			# else we have more chars to read
			PUSH 0[0]
			CONSTI -1
			MULI
			CONSTI -3
			ADDI 		# top of stack <- offset to next param
			PUSHI 0		# push address param onto the stack
			READC		# get char from stdin
			IFERR __readln_str_err 
			DUP		# push extra copy of read in char onto
					# stack as we need to test it for
					# equality with newline
			CONSTI 10	# ascii val of newline char
			EQI		# see read in char == newline
			IFNZ __readln_str_nl_done
			POPI 		# store read char at &x
			# decrement # of chars left to print
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
			GOTO __readln_str_loop

__readln_str_nl_done	# stopped reading because we caugh a newline, so
			# we have two extra values on stack we need to kick off
			ADJUST -2
			GOTO __readln_str_done

__readln_str_done	ADJUST -1
			CONSTI 10
			WRITEC
			RET 0

__readln_str_err	CONSTI 90	# TODO: print real error message
			WRITEC
			STOP



__readln_int		PUSH -3[0]	# push &x onto stack
			READI		# read int from stdin
			IFERR __readln_int_err
			POPI		# pop value read from stdin to
					# address specified by param
			READC		# consume newline
			WRITEC
			RET 0		
			

__readln_int_err	# TODO: produce error message
			CONSTI 90
			WRITEI
			STOP

__readln_real		PUSH -2[0]	# push &x onto stack
			READR		# read real from stdin
			IFERR __readln_real_err
			POPI		# pop value read from stdin to addr
					# specified by param
			READC		# consume newline
			WRITEC
			RET 0		

__readln_real_err	STOP 		# TODO print error




# Asc implementation of trunc()
# From the expression x that shall be of real-type, this function shall return
# a result of integerType.  The value of trunc(x) shall be such that if x is
# positive or zero, then 0 < x-trunc(x) < 1; otherwise -1 < x- trunc(x) < 0.
# It shall be an error if such a value does not exist.
# TODO: when can an error occur?
# NOTE: super easy, ROTI does trunc() for us.
__trunc		CONSTI 0
		PUSH -3[0]
		CALL 0, __is_bad_real
		ADJUST -1
		IFNZ __trunc_err
		PUSH -3[0]
		RTOI
		POP -4[0]
		RET 0

__trunc_err	# print err mesg
		STOP

###############################################################################
# sin(x) - returns the value of the sine of x where x is in radians.
# We're going to approximate the value of sine by calculating "enough" terms
# of its Taylor series.
###############################################################################

__sin_int		PUSH -3[0]	# push x onto stack
			ITOR		# conver to real
			POP -3[0]	# push into param slot
			GOTO __sin_real	# "call" real valued version of sin()

__sin_real		ADJUST 1	# make room for k = summation index
					# in the taylor series for sine
			CONSTI 6	# We are going to sum the first 6
					# series
			POP 0[0]

			ADJUST 1	# make room for (-1)^k
			CONSTR 0.0	
			POP 1[0]	# set (-1)^k = 0 for now

			ADJUST 1	# make room for (2k + 1)!
			CONSTR 0.0
			POP 2[0]	# set it to zero for now

			ADJUST 1	# make room for x^(2k+1) and set to 0
			CONSTR 0.0
			POP 3[0]

			# make room for value of sum so far, set to 0
			ADJUST 1	
			CONSTR 0.0
			POP 4[0]

			GOTO __sin_loop

__sin_loop		PUSH 0[0]	# push k onto stack
			CONSTI -1	# push -1 onto stack
			ADDI		# k <- k-1
			POP 0[0]	# save new value of k
			PUSH 0[0]	# push k onto stack
			CONSTI 0	# push 0 onto stack
			LTI
			IFNZ __sin_done	# k < 0 => we are done
			# else, we calculate the next summand

			#first calculate (-1)^k, make call to __pow_int_int
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k as second param
			CONSTI -1	# push -1 as first param
			CALL 0, __pow_int_int
			ADJUST -2	# kick params off the stack
			POP 1[0]	# save (-1)^k back into local vars

			#next calculate (2k + 1)!
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k onto stack
			CONSTI 2	# push 2 onto stack
			MULI		# top of stack <-- 2*k
			CONSTI 1	# push 1 onto stack
			ADDI		# top of stack <-- 2*k + 1
			CALL 0, __factorial
			ADJUST -1	# kick param off stack
			POP 2[0]	# save (2k+1)! back into local vars

			# next we calculate x^(2k+1)
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k onto stack
			CONSTI 2	# push 2 onto stack
			MULI		# top of stack <-- 2*k
			CONSTI 1	# push 1 onto stack
			ADDI		# top of stack <-- 2k+1
			PUSH -3[0]	# push x onto stack
			CALL 0, __pow_real_int
			ADJUST -2	# kick local vars off the stack
			POP 3[0]	# save val back into local vars

			# we're finally ready to calculate the summand
			PUSH 1[0]	# push (-1)^k
			PUSH 2[0]	# push (2k + 1)!
			DIVR		# top of stack <-- (-1)^k/(2k+1)!
			PUSH 3[0]	# push x^(2k+1)
			MULR		# top of stack <-- summand
			PUSH 4[0]	# push sum so far onto stack
			ADDR		# add summand to sum so far
			POP 4[0]	# save sum so far
			GOTO __sin_loop

__sin_done		PUSH 4[0]	# push sum so far onto stack
			POP -4[0]	# save it as ret value
			ADJUST -5	#kick local vars off the stack
			GOTO __sin_ret
__sin_ret		RET 0



# ASC implementation of the function sqr.
# square of x
# It shall be an error if such a value does not exist.
# TODO: insure all errors are caught (NOT THE CASE RIGHT NOW)
__sqr_int	PUSH -3[0]		# push x onto stack
		PUSH -3[0]		# push x onto stack (again)
		MULI			# top of stack <-- x * x
		GOTO __sqr_ret

__sqr_real	CONSTI 0
		PUSH -3[0]
		CALL 0, __is_bad_real
		IFNZ __sqr_err
		PUSH -3[0]
		PUSH -3[0]
		MULR
		GOTO __sqr_ret

__sqr_err	# print error message
		RET 0

__sqr_ret	POP -4[0]
		RET 0



# ASC implementation of the sqrt() function.
# non-negative square root of x, if x is not negative
# It shall be an error if x is negative.
# The standard specifies that sqrt() accepts both ints and reals, but always returns real.
# The strategy employed follows from en.wikipedia.org/wiki/Square_root
# To find sqrt(x), do:
#	-> start with arbitrary a, set a <-- (a + x/a)
#	-> keep iterating the value of a as give above, apparently you'll eventually get close
__sqrt_int		PUSH -3[0]		# push x onto stack
			ITOR			# convert it to a real
			POP -3[0]
			PUSH -3[0]
			GOTO __sqrt

__sqrt_real		PUSH -3[0]		# push x onto stack
			GOTO __sqrt

__sqrt			CONSTR 0.0		# push 0 onto stack, x now underneath 0
			LTR			# if x < 0 push 1, else push 0
			IFNZ __sqrt_err
						# x >= 0, if it's 0 let's not waste our time
						# computing
			PUSH -3[0]
			CONSTR 0.0
			EQR
			IFNZ __sqrt_ret		# if x == 0, we're done, else x > 0 and
						# we have work to do
			ADJUST 2		# make room for # of iters and a on stack
			CONSTI 10000		
			POP 0[0]		# number of iters <-- 10,000
			PUSH -3[0]
			CONSTR 2.0
			DIVR
			POP 1[0]		# initial guess for a = x / 2
			GOTO __sqrt_loop

__sqrt_loop		PUSH 0[0]		# push number of iters onto stack
			IFZ __sqrt_done		# if == 0, we're done
			PUSH 0[0]
			CONSTI -1
			ADDI			# else, decrement number of iters
			POP 0[0]		# and save it back in its place
			
			PUSH -3[0]		# push x onto stack
			PUSH 1[0]		# push a onto stack
			DIVR			# top of stack <-- x/a
			PUSH 1[0]		# push a onto stack
			ADDR			# top of stack <-- a + (x/a)
			CONSTR 2.0		# push 2.0 onto stack
			DIVR			# top of stack <- (a + (x/a))/2
			POP 1[0]		# a_new <-- stop of stack
			GOTO __sqrt_loop

__sqrt_done		ADJUST -2		# get rid of our local variables
			PUSH 1[0]		# put a onto stack
			GOTO __sqrt_ret

__sqrt_err		# print error message (write script to help do this stuff)
			STOP

__sqrt_ret		POP -4[0]
			RET 0


# ASC implementation of the succ(x) function.
# From the expression x that shall be of an ordinal-type, this function shall
# return a result that shall be of the same type as that of the expression x.
# The function shall yield a value whose ordinal number is one greater than that
# of the expression x, if such a value exists.  It shall be an error if such a 
# value does not exist.
#

__succ_int		PUSH -3[0]	# push x onto the stack
			# TODO: make sure x < maxint
			CONSTI 1	# push 1 onto stack
			ADDI		# top of stack <-- x + 1
			POP -4[0]	# store x+1 as ret value
			RET 0				

__succ_int_err		# the integer give was == maxint, cannot get successor
			STOP

__succ_bool		PUSH -3[0]
			IFNZ __succ_bool_err	# bool > 0 => no successor
			CONSTI 1	# push 1 onto stack
			POP -4[0]	# make 1 ret value
			RET 0

__succ_bool_err		# print error message
			STOP

__succ_char		PUSH -3[0]	# push x onto stack
			CONSTI 255	# push ascii val of '9' onto stack
			EQI		# if x == '9', need ret = 'A', else
					# check if x is next boundary value 'Z' 
			IFNZ __succ_char_err
			PUSH -3[0]
			CONSTI 255
			GTI
			IFNZ __succ_char_err	# char with val >255 => no succ
			PUSH -3[0]
			CONSTI 1
			ADDI
			POP -4[0]
			RET 0

__succ_char_err 	# no successor
			STOP

# For scalar types we get to have even more fun.  Each item in an enumerated
# scalar type is represented internally as a const -- so that's easy to 
# increment.  The bit of extra work is that we need to also pass to succ() the
# largest value amongst the consts in the enumerated type (e.g., the number
# of elements in the enumerated scalara - 1, where we subtract 1 as the
# standard specifies that the values of the constants beings at 0).  This
# "largest" value will be passed as the second parameter to __succ_scalar
__succ_scalar		PUSH -3[0]	# push x onto the stack
			PUSH -4[0]	# push x_max onto the stack
			# We should only have to test for equality if we
			# are performing error checking correctly elsewhere
			# in the program
			EQI
			IFNZ __succ_scalar_err
			PUSH -3[0]
			CONSTI 1
			ADDI
			POP -5[0]
			RET 0
__succ_scalar_err	# print error message
			STOP




# ASC implementation of round()
# From the expression x that shall be of real-type, this function shall return
# a result of integertype.  If x is positive or zero, round(x) shall be 
# equivalent to trunc(x + 0.5) ; otherwise, round(x) shall be equivalent to
# trunc(x - 0.5).  It shall be an error if such a value does not exist.  It
# shall be an error if such a value does not exist.
# TODO: check for error in case of x = inf or x = nan
__round			PUSH -3[0]
			CONSTR 0.0
			GTR
			IFNZ __round_pos
			PUSH -3[0]
			CONSTR 0.0
			EQR
			IFNZ __round_zero
			GOTO __round_neg

__round_pos		CONSTI 0	# make room for ret on stack
			PUSH -3[0]
			CONSTR 0.5	
			ADDR		# x <-- x + 0.5
			CALL 0, __trunc
			ADJUST -1	# kick param off the stack
			POP -4[0]	# make ret val from trunc() our ret val
			GOTO __round_ret

__round_zero		CONSTI 0	# x == 0.0, return int 0
			POP -4[0]
			GOTO __round_ret

__round_neg		CONSTI 0	# make room for ret val on stack
			PUSH -3[0]
			CONSTR -0.5
			ADDR
			CALL 0, __trunc
			ADJUST -1	# kick param off the stack
			POP -4[0]	# make ret val from trunc() our ret val
			GOTO __round_ret

__round_ret		RET 0


# ASC implementation of write().
# HOW TO CALL:
#	-> For ints/reals, simply push param as usual and call.
#	-> For chrs/string, push number of chars to print as first param
#	    (i.e., at -3[0]), we then print the last param first (so 
#	    just throw everything onto the stack in the order you get it,
#	    then push number of params to print and then call write)
__write_str		ADJUST 1	# make number of args a local param
			PUSH -3[0]
			POP 0[0]
			GOTO __write_str_loop
__write_str_loop	PUSH 0[0]	# top of stack <-- # left to print
			IFZ __write_str_end	# nothing more to print, exit
			# else we have a char to write
			# start by calculating depth of 0[0]th param
			PUSH 0[0]
			CONSTI -1
			MULI		
			CONSTI -3
			ADDI
			PUSHI 0		# push next char onto stack
			WRITEC		# write the character
			# decrement # of args
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
			GOTO __write_str_loop
__write_str_end		ADJUST -1	# kick local vars off the stack
			RET 0

__write_int		PUSH -3[0]
			WRITEI
			RET 0

__write_real		PUSH -3[0]
			WRITER
			RET 0



# ASC implementation of writeln.

__writeln_str		ADJUST 1	# make number of args a local param
			PUSH -3[0]
			POP 0[0]
			GOTO __writeln_str_loop
__writeln_str_loop	PUSH 0[0]	# top of stack <-- # left to print
			IFZ __writeln_str_end	# nothing more to print, exit
			# else we have a char to write
			# start by calculating depth of 0[0]th param
			PUSH 0[0]
			CONSTI -1
			MULI		
			CONSTI -3
			ADDI
			PUSHI 0		# push next char onto stack
			WRITEC		# write the character
			# decrement # of args
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
			GOTO __writeln_str_loop
__writeln_str_end	ADJUST -1	# kick local vars off the stack
			CONSTI 10	# we're writeln, so we write newchar
					# before we go away
			WRITEC
			RET 0

__writeln_int		PUSH -3[0]
			WRITEI
			CONSTI 10
			WRITEC
			RET 0

__writeln_real		PUSH -3[0]
			WRITER
			CONSTI 10
			WRITEC
			RET 0

	
¸

